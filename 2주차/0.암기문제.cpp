<인접행렬>
정점은 0번 부터 9번까지 10개의 노드가 있다. 1 - 2 /  1 - 3 / 3 - 4 라는 경로가 있다.
(1번과 2번, 1번과 3번, 3번과 4번은 연결되어있다.) 이를  이를 인접행렬로 표현한다면?

0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수를 만들고 
싶다면 어떻게 해야할까? 또한, 정점을 방문하고 다시 방문하지 않게 만드려면 어떻게 해야할까?


<인접리스트>

Q1.
1번.
정점은 0번 부터 9번까지 10개의 노드가 있다. 1 - 2 /  1 - 3 / 3 - 4 라는 경로가 있다. 
(1번과 2번, 1번과 3번, 3번과 4번은 연결되어있다.) 이를 인접리스트로 표현한다면? 
2번. 
0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 
재귀함수를 만들고 싶다면 어떻게 해야할까? 또한, 정점을 방문하고 다시 방문하지 않게 
만드려면 어떻게 해야할까?


<맵과 방향벡터>
Q1.{0, 0}좌표에서 dy, dx를 만들어 4방향(위, 오른쪽, 아래, 왼쪽)을 탐색하며 좌표를 출력하시오.
Q2. {0, 0}좌표에서 dy, dx를 만들어 8방향(위, 오른쪽, 아래, 왼쪽 및 대각선방향포함)을 탐색하며
 좌표를 출력하시오.
Q3. Q. 3 * 3 맵을 입력받아야 함. 이 맵은 1과 0으로 이루어져있고 {0, 0}은 무조건 
1임을 보장한다. {0, 0}부터 4방향을 기준으로 한칸씩 탐색해나가며 방문한 정점은 다시 방문하지 
않으며 방문하는 좌표를 출력하는 코드. 0은 갈 수 없는 지역. 
1은 갈 수 있는 지역을 구현하시오.


<dfs>
하남자의 DFS: 두들기고 건너...
상남자의 DFS: 일단 건너!!!
Q.종화는 방구쟁이야 ~~
종화는 21세기 유명한 방구쟁이다. 종화는 방구를 낄 때 "이러다... 다 죽어!!" 를 외치며 방구를 뀌는데 
이렇게 방귀를 뀌었을 때  방귀는 상하좌우 네방향으로 뻗어나가며 종화와 연결된 
"육지"는 모두 다 오염된다. "바다"로는 방구가 갈 수 없다. 
맵이 주어졌을 때 종화가 "이러다... 다 죽어!!"를 "최소한" 
몇 번외쳐야 모든 육지를 오염시킬 수 있는지 말해보자. 1은 육지며 0은 바다를 가리킨다.
 범위 : 1 <= N <= 100, 1 <= M <= 100
 예제입력
5 5
1 0 1 0 1
1 1 0 0 1
0 0 0 1 1
0 0 0 1 1
0 1 0 0 0

출력 : 4

<BFS>
수도1보고 작성
먼저 시작지점인 u를 "방문처리"를 하고 "큐(queue)에 푸시"를 합니다. 그리고 q.size() 만큼
 while 반복문을 돌면서 큐 앞단의 있는 u를 다시 끄집어내서 그 u를 중심으로 인접한 노드들을
  탐색을 합니다. 방문한 정점은 다시 방문하지 않고 방문처리를 하면서 큐(queue)에 푸시를
   하며 방문처리를 합니다. 

BFS(G, u)
    u.visited = true
    q.push(u);
    while(q.size()) 
        u = q.front() 
        q.pop()
        for each v ∈ G.Adj[u]
            if v.visited == false
                v.visited = true
                q.push(v) 

수도코드1은 방문처리만을 하는 코드입니다. 하지만 보통 문제에서 BFS를 쓸 때는 가중치가 같은
 그래프 내에서 최단거리 알고리즘으로 쓰입니다. 그러기 위해 "최단거리 배열"을 방문하면서
  만들어주어야 하는데 다음과 같은 수도코드를 사용합니다. 

BFS(G, u)
    u.visited = 1
    q.push(u);
    while(q.size()) 
        u = q.front() 
        q.pop()
        for each v ∈ G.Adj[u]
            if v.visited == false
                v.visited = u.visited + 1
                q.push(v) 


10번 정점부터 탐색하고 인접리스트로 표현해서 코드작성해봐
int nodeList[] = {10, 12, 14, 16, 18, 20, 22, 24};

당근마켓 엔지니어 승원이
승원이는 당근을 좋아해서 당근마킷에 엔지니어로 취업했다. 당근을 매우좋아하기 때문에 
차도 당근차를 샀다. 이 당근차는 한칸 움직일 때마다 당근을 내뿜으면서 간다. 즉,
 "한칸" 움직일 때 "당근한개"가 소모된다는 것이다. 승원이는 오늘도 아침 9시에 
 일어나 당근마킷으로 출근하고자 한다. 승원이는 최단거리로 당근마킷으로 향한다고 
 할 때 당근몇개를 소모해야 당근마킷에 갈 수 있는지 알아보자. 이 때 승원이는 육지로만
  갈 수 있으며 바다로는 못간다. 맵의 1은 육지며 0은 바다를 가리킨다. 
  승원이는 상하좌우로만 갈 수 있다. 

입력
맵의 세로길이 N과 가로길이 M 이 주어지고 이어서 N * M의 맵이 주어진다. 
그 다음 줄에 승원이의 위치(y, x)와 당근마킷의 위치(y, x)가 주어진다. 
이 때 승원이의 시작위치(y, x)에서 "당근한개"가 이미 소모된 상태로 본다.

출력
당근을 몇개 소모해야 하는지 출력하라.

범위 : n,m 최대 100
예제
5 5
0 0
4 4
1 0 1 0 1
1 1 1 0 1
0 0 1 1 1
0 0 1 1 1
0 0 1 1 1
출력 : 9


